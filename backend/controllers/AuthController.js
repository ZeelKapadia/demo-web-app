const User = require("../models/User");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const status_codes = require('http-status-codes').StatusCodes;

const register = (req, res, next) => {
    bcrypt.hash(req.body.password, 10, function (err, hashedPass) {
        if (err) {
            res.status(status_codes.BAD_REQUEST).json({
                error: err
            })
        }
        let user = new User({
            name: req.body.name,
            email: req.body.email,
            mobile: req.body.mobile,
            password: hashedPass
        })
        // var error = user.validate()
        // if (error) {
        //     res.status(status_codes.BAD_REQUEST).send({
        //         message:"Null values or empty values are not allowed"
        //     })
        // }
        // else{
            User.find().then((response)=>{
                if (response.name === user.name || response.email === user.email || response.mobile === user.mobile) {
                    res.status_codes(status_codes.BAD_REQUEST).json({
                        message:"Duplicate values are not allowed"
                    })
                }
                else{
                    user.save().then((user) => {
                        res.status(status_codes.CREATED).json({
                            message: "User Added Successfully"
                        })
                    }).catch(er=>{
                        res.status(status_codes.BAD_REQUEST).json({
                            message: "try with another credentials"
                        })
                    }) 
                }
            }).catch(err=>{
                res.status(status_codes.BAD_REQUEST).json({
                    message: "User has been Already registered"
                })
            })
        // }
    })
}

const login = (req, res, next) => {
    var username = req.body.username;
    var password = req.body.password;

    User.findOne({ $or: [{ email: username }, { mobile: username }, { name: username }] }).then(user => {
        if (user) {
            bcrypt.compare(password, user.password, function (err, result) {
                if (err) {
                    res.status(status_codes.BAD_REQUEST).json({
                        error: err
                    })
                }
                else if (result) {
                    let token = jwt.sign({ name: user.name }, process.env.ACCESS_TOKEN_SECRET, { expiresIn: process.env.ACCESS_TOKEN_EXPIRE_TIME })
                    let refreshToken = jwt.sign({ name: user.name }, process.env.REFRESH_TOKEN_SECRET, { expiresIn: process.env.REFRESH_TOKEN_EXPIRE_TIME })
                    res.status(status_codes.OK).json({
                        message: "Login Successful!",
                        token: token,
                        refreshToken: refreshToken
                    })
                }
                else {
                    res.status(status_codes.EXPECTATION_FAILED).json({
                        message: "password doesnt match"
                    })
                }
            })
        }
        else {
            res.status(status_codes.OK).json({
                message: "User not Found"
            })
        }
    })
}

const refreshToken = (req, res, next) => {
    const refreshToken = req.body.refreshToken
    jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET, function (err, decode) {
        console.log("here is your cursor");
        if (err) {
            console.log("inside error");
            res.status(status_codes.BAD_REQUEST).json({
                err
            })
        }
        else {
            let token = jwt.sign({ name: decode.name }, process.env.ACCESS_TOKEN_SECRET, { expiresIn: process.env.ACCESS_TOKEN_EXPIRE_TIME })
            let refreshToken = req.body.refreshToken
            res.status(status_codes.OK).json({
                message: "Token refreshed Successfully!",
                token: token,
                refreshToken: refreshToken
            })
        }
    })
}

const getAdminUser = (req, res, next) => {
    User.find().then(resp => {
        if (resp.length > 0) {
            res.status(status_codes.OK).send({
                resp
            })
        }
        else {
            res.status(status_codes.NO_CONTENT).send(resp)
        }
    })
}

const autoGeneratedPass=(req,res,next)=>{
    let result = ' ';
    const capLetters="ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const lowLetters="abcdefghijklmnopqrstuvwxyz";
    const digits="01234567890";
    const specialSymbols="~!@#$%^&*()_+}{|:<>?-=`[];',./\\";
    const passwordString = capLetters+lowLetters+digits+specialSymbols
    const length=15;
    for ( let i = 0; i < length; i++ ) {
        result += passwordString.charAt(Math.floor(Math.random() * passwordString.length));
    }
    res.status(status_codes.OK).json({
        result
    })
}
module.exports = {
    register, login, refreshToken, getAdminUser,autoGeneratedPass
}